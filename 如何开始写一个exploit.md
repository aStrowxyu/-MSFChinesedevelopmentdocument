## 如何开始写一个exploit
exploit开发真正的功夫在背后.而实际不是你选择的开发语言,
它是关于你对于正在调试的应用程序如何处理输入以及如何通过操作来获得控制权的正确理解
没错，关键字是“调试”。 你的binjitsu(逆向工程),真正的功夫在哪里。但是，如果你的目标不仅仅是弹出一个计算器，而是实际上想要武器化，维持和提供实际应用，
你需要一个开发框架。 Metasploit就是这样开发的。这个框架是免费的,开源,由世界各地的研究人员积极贡献。
所以当你编写Metasploit漏洞的时候，你不必担心任何依赖性问题，或者版本错误，或者没有足够的有效载荷供不同的渗透场景选择，等等。你需要思考的就是专注于构建这个漏洞利用，而不是别的。

### 计划你的模块
与编写概念证明不同，当您编写Metasploit模块时，您需要考虑用户如何在现实世界中使用它。隐藏通常是一个重要的考虑因素。您的exploit可以在不丢弃文件的情况下执行代码吗？输入能看起来更随机,通过更多不同的检测?如何混淆?它是否产生不必要的流量？它能更稳定而不会造成系统崩溃等等.
另外，请尽量准确地考虑可利用的需求。通常,一个bug是特定于一系列的版本.甚至是build.如果你不能自动检查,你至少需要在描述中提到它.您的一些漏洞利用技术也可能是特定于应用程序的.
就像,您可以利用应用程序中的特定行为以您希望的方式生成堆分配，但是在较新版本中可能会更混乱,因此会给您带来一些稳定性问题.
是否需要第三方组件才能工作，甚至可能不会被所有人安装？即使是这样，是否经常修改组件，可能会使您的漏洞不太可靠？
要知道,在现实世界中,你的利用可能会以很多不同的方式打断或失败.在开发和测试阶段,你应该尝试找出并修复它,在学习困难的方式之前.

### rank
正如你所看到的，可靠性对于Metasploit来说很重要，我们试图对用户更加友好。我知道你在想什么：“好吧，如果他们正在利用漏洞，他们应该明白它是如何运作的，所以他们知道自己正在陷入困境。” 在完美的世界里，是的。
了解漏洞的工作方式或者exploit的工作方式只会使用户受益，但是你知道，我们并不是生活在完美的世界。如果您正在进行渗透测试，那么不可能总是找到时间重新创建易受攻击的环境，分割exploit到最基本的形式来调试正在发生的事情，然后再进行测试。
你可能有一个紧张的日程安排，打入一个大型的网络，所以你需要小心使用你的时间。正因为如此，至少对模块有很好的描述和很好的参考。当然，可以信任的rank系统。
Metasploit框架有七个不同的rank来表明漏洞的可靠性。请参阅漏洞利用rank了解更多详情。

### 模板
如果你已经读了这么多，我们认为你是相当的印象深刻.因为要消化很多.你可能想知道为什么我没有分享一行代码?
呃，你记得，利用开发主要是关于你的逆向技能。如果你有这一切,我们不应该告诉你如何写一个利用.
我们到目前为止所做的是希望你的心态正确,成为安全社区的Metasploit漏洞利用开发者意味着什么,剩下的更多的是如何使用我们的mixins构建exploit.
那么，有很多mixin，所以不可能在一个页面中浏览所有的，所以你必须阅读[API文档](https://github.com/rapid7/metasploit-framework/wiki/How-to-Send-an-HTTP-Request-Using-HTTPClient),现有的代码示例,或者寻找更多的wiki页面,我们已经写了特定的mixin。
例如，如果您正在寻找关于如何与HTTP服务器交互的文章，您可能会对以下内容感兴趣：[如何使用HTTPClient发送HTTP请求](https://github.com/rapid7/metasploit-framework/wiki/How-to-Send-an-HTTP-Request-Using-HTTPClient)。如果您对浏览器漏洞利用感兴趣，请务必查看：如何使用BrowserExploitServer编写浏览器漏洞利用程序等
但是，当然，开始你很可能需要一个模板来处理，在这里。我们还将解释如何填写必填字段

~~~
##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  def initialize(info={})
    super(update_info(info,
      'Name'           => "[Vendor] [Software] [Root Cause] [Vulnerability type]",
      'Description'    => %q{
        Say something that the user might need to know
      },
      'License'        => MSF_LICENSE,
      'Author'         => [ 'Name' ],
      'References'     =>
        [
          [ 'URL', '' ]
        ],
      'Platform'       => 'win',
      'Targets'        =>
        [
          [ 'System or software version',
            {
              'Ret' => 0x41414141 # This will be available in `target.ret`
            }
          ]
        ],
      'Payload'        => {
          'BadChars' => "\x00"
        },
      'Privileged'     => false,
      'DisclosureDate' => "",
      'DefaultTarget'  => 0))
  end

  def check
    # For the check command
  end

  def exploit
    # Main function
  end

end
~~~
Name字段应以供应商名称开头，后面跟着软件。理想情况下，“Root Cause”字段意味着发现错误的组件或功能。最后，模块正在利用的漏洞类型。
在Description字段应该解释模块做什么，什么事情要留意，具体要求，多多益善。目标是让用户了解他所使用的内容，而不需要实际读取模块的源代码并找出结果。相信我，他们中的大多数人不会。
Author 字段是你的名字。格式应该是“名称”。如果你想在那里有你的Twitter，留下它作为一个注释，例如:“名称＃handle”
References字段是与漏洞或exploit相关的参考数组。例如:咨询,博客文章等.确保您使用已知的引用标识符 - 请参阅[Metasploit模块引用标识符](https://github.com/rapid7/metasploit-framework/wiki/Metasploit-module-reference-identifiers)以获取列表。
该Platform字段表示所支持的平台，例如：win, linux, osx, unix, bsd.
targets字段是一个你的exploit是针对的系统,应用,设置或者特殊设置的数组.第二个元素整个数组是你储存目标的特殊元数据的位置.例如特定偏移量,小工具,ret地址等.当用户选择目标时，元数据将被加载并跟踪“target index”，并可以通过该target方法进行检索。
Payloads字段指定有效载荷应该如何被编码和生成。您可以指定：Space，SaveRegisters，Prepend，PrependEncoder，BadChars，Append，AppendEncoder，MaxNops，MinNops，Encoder，Nop，EncoderType，EncoderOptions，ExtendedOptions，EncoderDontFallThrough。
DisclosureDate是当漏洞被公开披露时，格式:: "M D Y". 例子: "Apr 04 2014"
你的漏洞也应该有一个check方法来支持check命令,但是这是可选的,因为如果这是不可能的。
最后，这个exploit方法就像你的main方法。开始在那里写你的代码。

### 基本的git命令
Metasploit不再使用svn进行源代码管理，而是使用git，所以了解git的一些技巧会有很长的路要走。
我们不是在这里教你git是多么的棒,我们知道它有一个学习曲线，新的用户犯错误并不奇怪。
每隔一段时间，你的git”怒火"就会踢过来，我们理解。不过，重要的是要利用分支
。
每次创建模块或对现有代码进行一些更改时，都不应该在默认主分支上这样做。为什么？因为当你使用msfupdate更新你的Metasploit仓库的工具时，它会在合并这些改变之前做一个git reset，你就要和你所有的代码说再见。

人们倾向于做的另一个错误是在提交拉取请求之前对主分支进行了任何更改.这是个坏主意,因为很可能你提交了你不打算改变的其他垃圾，或者你可能会要求我们合并其他不必要的提交历史.只要一次提交就行了.感谢你提交模块到社区,但不感谢你提交其他不必要的提交历史.

所以作为一种习惯，当你想要做出新的东西或者改变某些东西的时候，从最新的主分支分叉一个新的分支开始，首先,先确认你是master分支,如果你使用`git status`,它将会告诉你现在所在分支
~~~
$ git status
# On branch upstream-master
nothing to commit, working directory clean
~~~
好的,接下来`git pull`从metasploit下载最新更改
~~~
$ git pull
Already up-to-date.
~~~
现在,你准备开始一个新分支了.在这种情况,我们新分支的名字是"my_awesome_branch":
~~~
$ git checkout -b my_awesome_module
Switched to a new branch 'my_awesome_module'
~~~
现在你可以继续前进 添加一个模块.确认他在合适的路径
~~~
$ git add [module path]
~~~
当你决定保存更改时，提交（如果只有一个模块，你也可以这样做，git commit -a所以你不必输入模块路径，注意-a事实上意味着所有）
~~~
$ git commit [module path]
~~~
完成后，推送您的更改，将您的代码上传到您的远程分支“my_awesome_branch”。您必须推送您的更改才能提交拉取请求，或与互联网上的其他人共享。
~~~
$ git push origin my_awesome_branch
~~~