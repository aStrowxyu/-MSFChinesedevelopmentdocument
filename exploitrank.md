## exploit ranking
根据对目标系统的潜在影响，每个利用模块都被分配一个rank。用户可以根据rank对exploit进行搜索，分类和优先级排序。
ranking是通过在模块类声明在上方添加一个rank常量实现的
~~~ruby
class MetasploitModule < Msf::Exploit
    Rank = LowRanking
    def initialize(info={})
        ...
    end
    ...
end
~~~

这个ranking的值是下面的其中一个,按可靠性降序排列

|   Ranking |    Description |
| --- | --- |
|   ExcellentRanking |   这个漏洞永远不会使服务崩溃。这是SQL注入，CMD执行,RFI,LFI等的情况。没有典型的内存损坏漏洞应该给这个rank，除非有特殊情况 |
| GreatRanking   |   exploit有一个默认的目标和自动检测目标，或者在版本检查后使用特定于应用程序的返回地址。 |
|  GoodRanking  |   该exploit具有默认目标，这是这种类型的软件（英语，桌面应用程序的Windows 7，2012的服务器等）的“常见情况”。 |
|   NormalRanking |   这个漏洞是可靠的，但取决于一个特定的版本，不能（或不）可靠地自动检测。这个 |
|AverageRanking	| exploit通常是不可靠或者很难被利用的。|
| LowRanking  |  对于通用平台来说，exploit几乎不可能(或者低于50％的成功率)成功。  |
|  ManualRanking  |   这个exploit不稳定或难以exploit，基本上是一个DoS。当模块没有用处，除非用户特别配置（例如exploit /unix/webapp/php_eval),这个排名也被使用。 |

rank值是可用的模块类对象以及实例：
~~~
modcls = framework.exploits["windows/browser/ie_createobject"]
modcls.rank      # => 600
modcls.rank_to_s # => "excellent"

mod = modcls.new
mod.rank      # => 600
mod.rank_to_s # => "excellent"

~~~


