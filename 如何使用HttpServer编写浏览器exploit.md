Metasploit框架提供了可让你用于开发浏览器exploit的不同mixin，主要有[Msf::Exploit::Remote::HttpServer](https://github.com/rapid7/metasploit-framework/wiki/How-to-write-a-browser-exploit-using-HttpServer), Msf::Exploit::Remote::HttpServer::HTML and [Msf::Exploit::Remote::BrowserExploitServer](https://github.com/rapid7/metasploit-framework/wiki/How-to-write-a-browser-exploit-using-BrowserExploitServer). 这篇文章主要涵盖HttpServer mixin.
HttpServer mixin是所有HTTP服务器 mixin的母亲(像 BrowserExploitServer 和 HttpServer::HTML).要使用它，你的模块需要有一个“on_request_uri”方法，这个方法是HTTP服务器收到来自浏览器的HTTP请求时触发的回调。设置“on_request_uri”的例子：

```ruby
#
# Listens for a HTTP request.
# cli is the socket object, and request is a Rex::Proto::Http::Request object
#
def on_request_uri(cli, request)
	print_status("Client requests URI: #{request.uri}")
end
```
“on_request_uri”方法也是您可以创建HTTP响应的地方。这里有几个选择可以用来做这一点：
* **send_not_found(cli)** -  发送404到客户端。确保传递cli（套接字）对象。
* **send_redirect(cli, location='/', body='', headers={})**  - 将客户端重定向到一个新的位置。
* **send_response(cli, body, headers={})** - 向客户端发送响应。这种方法可能是你大部分时间使用的方法。
如果你看过我们的一些exploit模块，你也可以使用Exploit::Remote::HttpServer::HTML 代替  Exploit::Remote::HttpServer.用法大多相同，区别在于Exploit::Remote::HttpServer::HTML  mixin可以让你访问一些Javascript函数，如Base64，heap spraying，OS detection,等。
以下是发送HTTP响应的示例：

```ruby
#
# Sends a "Hello, world!" to the client
#
def on_request_uri(cli, request)
	html = "Hello, world!"
	send_response(cli, html)
end
```

另请注意，为了处理HTTP请求，它必须包含基本的URIPATH，默认情况下是随机的。这意味着如果你想处理多个URI（如果你需要处理重定向或链接的话可能），你还需要确保它们具有基本的URIPATH。要检索基本的URIPATH，可以使用“get_resource”方法，下面是一个例子：

```ruby
def serve_page_1(cli)
	html = "This is page 1"
	send_response(cli, html)
end

def serve_page_2(cli)
	html = "This is page 2"
	send_response(cli, html)
end

def serve_default_page(cli)
	html = %Q|
	<html>
	<a href="#{get_resource.chomp('/')}/page_1.html">Go to page 1</a><br>
	<a href="#{get_resource.chomp('/')}/page_2.html">Go to page 2</a>
	</html>
	|

	send_response(cli, html)
end

def on_request_uri(cli, request)
	case request.uri
	when /page_1\.html$/
		serve_page_1(cli)
	when /page_2\.html$/
		serve_page_2(cli)
	else
		serve_default_page(cli)
	end
end
```

当然，当你编写Metasploit浏览器漏洞的时候，还有很多需要考虑的东西。例如，您的模块可能需要执行浏览器检测，因为允许Chrome浏览器接收IE漏洞是没有意义的。您可能还需要构建特定于目标的负载，这意味着您的模块需要知道它的目标是什么，并且必须构建一个方法来相应地定制漏洞利用等。HttpServer和HttpServer::HTML mixin提供各种方法让你完成所有这些。确保查看API文档（可以通过运行msf / documentation / gendocs.sh，或者只是在msf目录中运行“yard”）或者检查现有的代码示例（特别是最近的代码示例）。
为了使事情开始，您可以始终使用以下模板开始开发浏览器利用：

```ruby
##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpServer

  def initialize(info={})
    super(update_info(info,
      'Name'           => "HttpServer mixin example",
      'Description'    => %q{
        Here's an example of using the HttpServer mixin
      },
      'License'        => MSF_LICENSE,
      'Author'         => [ 'sinn3r' ],
      'References'     => 
        [
          [ 'URL', 'http://metasploit.com' ]
        ],
      'Platform'       => 'win',
      'Targets'        =>
        [
          [ 'Generic', {} ],
        ],
      'DisclosureDate' => "Apr 1 2013",
      'DefaultTarget'  => 0))
  end

  def on_request_uri(cli, request)
    html = "hello"
    send_response(cli, html)
  end

end
```
如果你想仔细看看mixin可以做什么，请看

https://github.com/rapid7/metasploit-framework/blob/master/lib/msf/core/exploit/http/server.rb
