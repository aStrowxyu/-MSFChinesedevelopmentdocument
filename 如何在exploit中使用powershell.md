PowerShell是Microsoft开发的一种脚本语言。它提供了对Windows平台几乎所有内容的API访问，不容易被检测到，易于学习，因此对于渗透测试的后期开发过程中或payload执行的exploit开发来说非常强大。以Metasploit的[windows/smb/psexec_psh.rb](https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/windows/smb/psexec_psh.rb) 模块为例子.它模仿SysInternals中的psexec工具，有效载荷被压缩并从命令行执行，这使得它对防病毒有些隐蔽.psexec_psh.rb中只有不到30行代码（不包括描述模块的元数据），因为大部分工作都是由Powershell mixin完成的，没有比这更容易的了。
命令行将自动尝试检测正在运行的体系结构（x86或x86_64）以及它所包含的有效负载体系结构。如果存在不匹配的情况，则会生成正确的PowerShell体系结构以将有效载荷注入到内存中，因此无需担心目标系统的体系结构。

### 要求
要使用PowerShell mixin，请确保您符合以下要求

* 目标机器支持PowerShell。Vista或更新版本应该支持它。
* 您必须拥有执行powershell.exe的权限
* 您必须能够提供系统命令参数。
* 您必须设置命令执行类型为了执行powershell.exe攻击

### 示例

* 添加Powershell到你的模块,首先你需要require 它

```ruby
require 'msf/core/exploit/powershell'
```

* 然后把这个mixin包含在这个Metasploit3类的范围内（或者对于一些是Metasploit4）

```ruby
include Msf::Exploit::Powershell
```
* 使用该`cmd_psh_payload`方法生成PowerShell payload。

```ruby
cmd_psh_payload(payload.encoded, payload_instance.arch.first)
```

 ```cmd_psh_payload```实际输出是一个系统命令.它看起来像下面的格式(作为一行）
 
```
%COMSPEC% /B /C start powershell.exe -Command $si = New-Object
System.Diagnostics.ProcessStartInfo;$si.FileName = 'powershell.exe';
$si.Arguments = ' -EncodedCommand [BASE64 PAYLOAD] ';
$si.UseShellExecute = $false;
$si.RedirectStandardOutput = $true;$si.WindowStyle = 'Hidden';
$si.CreateNoWindow = $True;
$p = [System.Diagnostics.Process]::Start($si);
```

根据漏洞的情况，可以使用多种选项来调整最终的命令。默认情况下脚本是压缩的，但是没有编码发生在。这产生了一个约2000字符的小命令（取决于有效载荷）。
其中最值得一提的是`encode_final_payload` 将完整的负载Base64编码成一个非常简单的命令，并且很少有坏字符。但是，命令长度会因此而增加。结合`remove_comspec`意味着有效载荷将是非常简单的

`powershell.exe -nop -ep bypass -e AAAABBBBCCCCDDDD.....==`

在下面的api文档确认更多的高级选项

### References

https://dev.metasploit.com/api/Msf/Exploit/Powershell.html

https://github.com/rapid7/metasploit-framework/blob/master/lib/msf/core/exploit/powershell.rb


https://github.com/rapid7/metasploit-framework/blob/master/data/exploits/powershell/powerdump.ps1

 