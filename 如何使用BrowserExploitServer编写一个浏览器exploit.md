Metasploit框架提供了可让你用于开发浏览器exploit的不同mixin，主要有：
* **[Msf::Exploit::Remote::HttpServer](https://github.com/rapid7/metasploit-framework/wiki/How-to-write-a-browser-exploit-using-HttpServer)** - 一个最基本的http服务器
* **Msf::Exploit::Remote::HttpServer::HTML** -  这个模块提供JavaScript函数在制作不同的html内容时能使用
* **[Msf::Exploit::Remote::BrowserExploitServer](https://github.com/rapid7/metasploit-framework/wiki/How-to-write-a-browser-exploit-using-BrowserExploitServer)** - 包括来自HttpServer和HttpServer :: HTML的功能，但还有更多的好东西。这篇文章涵盖了 [BrowserExploitServer](https://rapid7.github.io/metasploit-framework/Msf/Exploit/Remote/BrowserExploitServer.html) mixin.

### 自动开发程序
BrowserExploitServer mixin是唯一专门为浏览器开发的mixin。在使用这个mixin之前，你应该明白它在背后的作用：
1.它会自动收集浏览器信息，包括：操作系统名称，版本，浏览器名称，浏览器版本，是否使用代理，Java插件版本，Microsoft Office版本等。如果浏览器没有启用Javascript，那么它对目标知道的很少。收集的所有信息将存储在由mixin管理的配置文件中。
2.然后mixin会标记浏览器来跟踪会话。它也将使用相同的标签来检索需要的配置文件。
3.在mixin决定是否应该向浏览器使用exploit之前，它会检查模块是否有任何可exploit的条件。如果不符合条件，则会向浏览器发送一个404，放弃操作
4.如果满足要求，mixin会将该配置文件（在检测阶段收集的浏览器信息）传递给模块，然后让其接管其余部分。
提示：在模块中，您可以检查配置文件中的`:source`键以确定是否启用Javascript：如果：source是“script”，则意味着启用了Javascript。如果是“headers”（如HTTP标头），那么浏览器禁用Javascript。

### 设置可exploit要求
能够设置浏览器的要求是mixin的一个重要特性。它可以让你的攻击更聪明，更有针对性，并防止事故发生。这里有一个场景：假设你有一个针对Internet Explorer的漏洞，它只影响特定范围的MSHTML构建，你可以设置:os_name, :ua_name, :ua_ver, and :mshtml_build 来确保它不会盲目的exploit其他东西.:mshtml_build要求可以在MSHTML文件属性下的“产品版本”中找到。
可利用的浏览器要求在模块元数据的“BrowserRequirements”下定义。以下是定义运行某个ActiveX控件的易受攻击目标的示例：

```ruby
'BrowserRequirements' =>
{
	source: /script/i,
        activex: [
          {
            clsid: '{D27CDB6E-AE6D-11cf-96B8-444553540000}',
            method: 'LoadMovie'
          }
        ],
	os_name: /win/i
}
```

您也可以定义目标特定的要求。这也是mixin能够自动选择一个目标的方式，你可以用“get_target”方法得到它。下面是一个例子，说明如何定义目标特定的要求,在Win XP上的IE8，在Win 7上的IE 9 ：

```ruby
'BrowserRequirements' =>
  {
    :source   => /script|headers/i,
    'ua_name' => HttpClients::IE,
  },
'Targets'             =>
  [
    [ 'Automatic', {} ],
    [
      'Windows XP with IE 8',
      {
        :os_name    => 'Windows XP',
        'ua_ver'    => '8.0',
        'Rop'       => true,
        'Offset'    => 0x100
      }
    ],
    [
      'Windows 7 with IE 9',
      {
        'os_name'   => 'Windows 7',
        'ua_ver'    => '9.0',
        'Rop'       => true,
        'Offset'    => 0x200
      }
    ]
  ]
```

你可以使用这些  **:os_name**:

| Constant | Purpose |
| -------- | ----- |
| OperatingSystems::Match::WINDOWS | Match all versions of Windows |
| OperatingSystems::Match::WINDOWS_95 | Match Windows 95 |
| OperatingSystems::Match::WINDOWS_98 | Match Windows 98 |
| OperatingSystems::Match::WINDOWS_ME | Match Windows ME |
| OperatingSystems::Match::WINDOWS_NT3 | Match Windows NT 3 |
| OperatingSystems::Match::WINDOWS_NT4 | Match Windows NT 4 |
| OperatingSystems::Match::WINDOWS_2000 | Match Windows 2000 |
| OperatingSystems::Match::WINDOWS_XP | Match Windows XP |
| OperatingSystems::Match::WINDOWS_2003 | Match Windows Server 2003 |
| OperatingSystems::Match::WINDOWS_VISTA | Match Windows Vista |
| OperatingSystems::Match::WINDOWS_2008 | Match Windows Server 2008 |
| OperatingSystems::Match::WINDOWS_7 | Match Windows 7 |
| OperatingSystems::Match::WINDOWS_2012 | Match Windows 2012 |
| OperatingSystems::Match::WINDOWS_8 | Match Windows 8 |
| OperatingSystems::Match::WINDOWS_81 | Match Windows 8.1 |
| OperatingSystems::Match::LINUX | Match a Linux distro |
| OperatingSystems::Match::MAC_OSX | Match Mac OSX |
| OperatingSystems::Match::FREEBSD | Match FreeBSD |
| OperatingSystems::Match::NETBSD | Match NetBSD |
| OperatingSystems::Match::OPENBSD | Match OpenBSD |
| OperatingSystems::Match::VMWARE | Match VMWare |
| OperatingSystems::Match::ANDROID | Match Android |
| OperatingSystems::Match::APPLE_IOS | Match Apple IOS |

你能使用这些 **:ua_name**:

| Constant | Value |
| -------- | ----- |
| HttpClients::IE | "MSIE" |
| HttpClients::FF | "Firefox" |
| HttpClients::SAFARI | "Safari" |
| HttpClients::OPERA | "Opera" |
| HttpClients::CHROME | "Chrome" |

更多这些常量可以在这里找到:https://github.com/rapid7/metasploit-framework/blob/master/lib/msf/core/constants.rb
全部现在mixin支持的要求可以在这找到(查看 REQUIREMENT_KEY_SET))
https://github.com/rapid7/metasploit-framework/blob/master/lib/msf/core/exploit/remote/browser_exploit_server.rb#L46

### 设置一个监听器
在检测阶段和需求检查之后，mixin将触发“on_request_exploit”回调方法，这就是您处理HTTP请求，制作HTML并返回漏洞响应的地方。这里是一个如何设置“on_request_exploit”的例子：

```ruby
#
# Listens for the HTTP request
# cli is the socket
# request is the Rex::Proto::Http::Request object
# target_info is a hash that contains all the browser info (aka the profile)
#
def on_request_exploit(cli, request, target_info)
	print_status("Here's what I know about the target: #{target_info.inspect}")
end
```

### 使用BrowserExploitServer构建HTML
BrowserExploitServer mixin支持两种编码风格：好的旧的HTML或[ERB](http://ruby-doc.org/stdlib-2.1.3/libdoc/erb/rdoc/ERB.html)模板。首先是不言自明的：

```ruby
def on_request_exploit(cli, request, target_info)
	html = %Q|
	<html>
	Hello, world!
	</html>
	|
	send_exploit_html(cli, html)
end 
```

[ERB](http://ruby-doc.org/stdlib-2.1.3/libdoc/erb/rdoc/ERB.html) 是一种编写Metasploit浏览器漏洞的新方法。如果你已经写了一个或两个Web应用程序，这对你来说并不陌生。当您使用BrowserExploitServer mixin编写漏洞利用程序时，真正发生的是您正在编写一个rails模板。以下是使用此功能的示例：
```ruby
def on_request_exploit(cli, request, target_info)
	html = %Q|
	<html>
	Do you feel lucky, punk?<br>
	<% if [true, false].sample %>
	Lucky!<br>
	<% else %>
	Bad luck, bro!<Br>
	<% end %>
	</html>
	|
	send_exploit_html(cli, html)
end
```

如果要访问局部变量或参数，请确保将绑定对象传递给send_exploit_html：


```ruby
def exploit_template1(target_info, txt)
	txt2 = "I can use local vars!"

	template = %Q|
	<% msg = "This page is generated by an exploit" %>
	<%=msg%><br>
	<%=txt%><br>
	<%=txt2%><br>
	<p></p>
	Data gathered from source: #{target_info[:source]}<br>
	OS name: #{target_info[:os_name]}<br>
	UA name: #{target_info[:ua_name]}<br>
	UA version: #{target_info[:ua_ver]}<br>
	Java version: #{target_info[:java]}<br>
	Office version: #{target_info[:office]}
	|

	return template, binding()
end

def on_request_exploit(cli, request, target_info)
	send_exploit_html(cli, exploit_template(target_info, txt))
end
```

BrowserExploitServer mixin在制作exploit的同时还提供了许多其他有用的东西。例如：当您调用“get_payload”方法时，它可以生成特定于目标的有效内容。它还使您可以访问RopDb mixin,其中包含一组ROP以绕过DEP（数据执行保护）。请务必查看API文档以获取更多信息。
为了得到一个开始，下面是一个可以使用的代码示例，开始开发浏览器漏洞：

```ruby
##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::BrowserExploitServer

  def initialize(info={})
    super(update_info(info,
      'Name'           => "BrowserExploitServer Example",
      'Description'    => %q{
        This is an example of building a browser exploit using the BrowserExploitServer mixin
      },
      'License'        => MSF_LICENSE,
      'Author'         => [ 'sinn3r' ],
      'References'     =>
        [
          [ 'URL', 'http://metasploit.com' ]
        ],
      'Platform'       => 'win',
      'BrowserRequirements' =>
        {
          :source => /script|headers/i,
        },
      'Targets'        =>
        [
          [ 'Automatic', {} ],
          [
            'Windows XP with IE 8',
            {
              'os_name'   => 'Windows XP',
              'ua_name'   => 'MSIE',
              'ua_ver'    => '8.0'
            }
          ],
          [
            'Windows 7 with IE 9',
            {
              'os_name'   => 'Windows 7',
              'ua_name'   => 'MSIE',
              'ua_ver'    => '9.0'
            }
          ]
        ],
      'Payload'        => { 'BadChars' => "\x00" },
      'DisclosureDate' => "Apr 1 2013",
      'DefaultTarget'  => 0))
  end

  def exploit_template(target_info)
    template = %Q|
    Data source: <%=target_info[:source]%><br>
    OS name: <%=target_info[:os_name]%><br>
    UA name: <%=target_info[:ua_name]%><br>
    UA version: <%=target_info[:ua_ver]%><br>
    Java version: <%=target_info[:java]%><br>
    Office version: <%=target_info[:office]%>
    |

    return template, binding()
  end

  def on_request_exploit(cli, request, target_info)
    send_exploit_html(cli, exploit_template(target_info))
  end

end
```

### JavaScript 混淆
BrowserExploitServer依靠JSObfu mixin来支持JavaScript混淆。在编写JavaScript时，应该总是这样写：


```ruby
js = js_obfuscate(your_code)
```

该#js_obfuscate会返回一个Rex::Exploitation::JSObfu对象。要获得混淆的JavaScript，请调用以下#to_s方法：

```ruby
js.to_s
```

如果您需要访问混淆的符号名称，则可以使用#sym方法

```ruby
# Get the obfuscated version of function name test()
var_name = js.sym('test')
```

请注意，即使您的模块正在调用#js_obfuscate方法，默认情况下，除非用户设置JsObfuscate数据存储选项，否则混淆不会启动。此选项是一个OptInt，它允许您设置混淆次数（默认值为0）。

```ruby
deregister_options('JsObfuscate')
```

如果您的基于BES的攻击根本不需要混淆，请务必调用#deregister_options并移除JsObfuscate选项。像这样：

```ruby
deregister_options('JsObfuscate')
```

要了解有关Metasploit的JavaScript混淆功能的更多信息，请阅读[How to obfuscate JavaScript in Metasploit](https://github.com/rapid7/metasploit-framework/wiki/How-to-obfuscate-JavaScript-in-Metasploit).

### 相关文章

* https://github.com/rapid7/metasploit-framework/wiki/How-to-write-a-browser-exploit-using-HttpServer
* https://github.com/rapid7/metasploit-framework/wiki/Information-About-Unmet-Browser-Exploit-Requirements
